---
layout: post
title: "Session: Anonymous by Design"
excerpt: "Session est une application de messagerie privée conçue pour un monde où la confidentialité n’est plus la norme. Construite sur le réseau décentralisé Oxen, Session élimine les numéros de téléphone, les métadonnées et les serveurs centralisés "
excerpt_separator: "<!--more-->"
categories:
  - Security
tags:
  - Crypto
  - Metadata
last_modified_at: 2025-10-23T13:23:22-02:00
---

# Session : Kesako ?

Session repose sur **Oxen** (anciennement Loki), une blockchain conçue pour faire tourner un réseau décentralisé de serveurs appelés des *service nodes*.
Ces nœuds agissent comme des livreurs aveugles : ils relaient et stockent temporairement vos messages sans jamais savoir ce qu’ils transportent.

Quand vous envoyez un message, il est packé dans plusieurs couches de chiffrement et traverse différents nœuds — un procédé appelé **routage en oignon**, (cc Tor!) .
Chaque nœud ne connaît que le suivant,jamais l’expéditeur ni le destinataire.
Le message arrive dans un petit groupe de nœuds appelé **swarm**, associé à la clé publique du destinataire. 
Si ilest hors ligne, le swarm garde le message chiffré jusqu’à sa reconnexion.

Grâce à ce système, aucun serveur central ne peut detenir vos données :

- Les *service nodes* assurent le transport et le stockage chiffré
- La blockchain Oxen/Loki valide leur fiabilité et les récompense
- Session propose une messagerie où ni le contenu ni les métadonnées ne peuvent être exploités





## Mais au fait, Oxen/Loki, ça vient d’où ?

Pour faire simple, la blockchain Oxen peut se comprendre comme une **coopérative numérique mondiale** : chacun peut faire tourner une petite partie du réseau en échange d’une récompense automatique
Au lieu qu’une entreprise centralise la messagerie, les serveurs et les données, ce sont des opérateurs indépendants, contrôlés et rémunérés par la blockchain Oxen

!["Shut up and take my OXEN"](https://blog.lbrs.io/images/fry-oxen.jpg)

Imaginez un réseau mondial de petits serveurs: les **service nodes**.
Ils ne connaissent ni votre identité ni vos messages : ils ne voient passer que des paquets chiffrés. Leur role est de transporter et stocker ces données pour que des applications comme **Session** ou **Lokinet** (navigation anonyme) puissent fonctionner sans serveur central.

Pour participer, un opérateur doit **staker** des token OXEN. (SESH maintenant) C’est son **ticket d’entrée** :

- S’il respecte les règles (bonne connexion, mises à jour, disponibilité), il reçoit automatiquement des récompenses
- S’il tente de tricher ou s’il disparaît, il perd tout ou partie de son dépôt

Ce mécanisme s’appelle le **Proof of Stake**

How to run a session node: https://docs.getsession.org/contribute-to-the-session-network/running-a-session-node

Stake: https://stake.getsession.org/stake


## Pourquoi passer par une blockchain ?

La blockchain remplit trois rôles dans le réseau :

* Le registre : il consigne de manière transparente qui fait quoi, quand et comment. Chaque action est inscrite dans un journal infalsifiable.
* Le juge : elle vérifie automatiquement que chaque participant respecte les règles — disponibilité, performance, fiabilité.
* Le banquier : distribue les récompenses aux nœuds honnêtes et actifs, sans qu’aucune autorité centrale n’intervienne.

!["blockchain"](https://blog.lbrs.io/images/blockchain.jpg)

Tout repose sur le code, et tout est publiquement vérifiable.
Autrement dit, la confiance n’est plus une promesse : c’est by design

## Le smart contract et le jeton SESH

La blockchain Oxen a donné naissance au Session Network, une évolution où la logique économique repose sur un jeton appelé SESH.
SESH n’est pas un coin « miné » mais un smart contract — un petit programme déployé sur la blockchain Ethereum.
Il définit de manière immuable :

* le nombre total de jetons (240 millions) ;

* les règles de transfert et de récompense ;

* la répartition initiale entre la communauté, les opérateurs de nœuds et la fondation Session.

Le contrat est public : chacun peut vérifier sur Etherscan ou Arbiscan l’adresse officielle: 

``` 
0x10Ea9E5303670331Bdddfa66A4cEA47dae4fcF3b
```

et consulter les transactions en temps réel.

Ce jeton sert à financer le réseau et récompenser les opérateurs qui font tourner les service nodes.
Pour participer, un opérateur doit bloquer (staker) une certaine quantité de SESH : c’est sa garantie de bon comportement.
S’il reste en ligne et respecte les règles, le smart contract distribue automatiquement des récompenses.
Ce mécanisme transforme la confiance humaine en code : la sécurité économique du réseau ne dépend plus d’une entreprise mais d’un programme autonome vérifiable par tous.


### Le Oxen Name System (ONS)

Le **ONS** est l’équivalent décentralisé du DNS pour le réseau Oxen.
Il permet d’associer une **adresse lisible** à un identifiant cryptographique — par exemple `@leub.session` au lieu d’un long Session ID.
Ces correspondances sont inscrites directement sur la **blockchain Oxen**, ce qui garantit leur authenticité et empêche toute censure ou modification par un tiers.

Chaque nom ONS appartient à une clé publique et peut pointer vers un **profil Session**, une **adresse Lokinet**, ou d’autres services du réseau
L’enregistrement se fait via une transaction payée en **OXEN**, valable pour une durée limitée et renouvelable.

ONS rend l’usage de Session plus simple tout en conservant la confidentialité et la décentralisation du système.



## Les service node

Il vont se charger de trois choses:

- Relayer le trafic de manière chiffrée (mini-Tor intégré)
- Stocker temporairement les messages hors-ligne via les **swarms**
- Coopérer avec d’autres pour équilibrer le réseau

Grâce à cette architecture, le réseau devient **résilient** :  

![Privacy](https://blog.lbrs.io/images/whatspp-meme.jpg)


Oxen est donc la couche économique et logistique qui rend possible le fonctionnement de Session.
Elle aligne les motivations des opérateurs autour d’un objectif commun : faire tourner un réseau de communication anonyme, sans confiance centrale, où les données ne sont ni collectées ni revendues.

# SESSION

![Illustration Session](https://getsession.org/_next/image?url=https%3A%2F%2Fimages.ctfassets.net%2Ftl6gyyqswoaz%2F2sdLz8XFxQ1Nx7VFdiLXY7%2F95cbfe97d31cac2dd47db5dfa28fc3ca%2FArtboard_1__2_.png&w=3840&q=75)

Whitepaper: https://arxiv.org/pdf/2002.04609

## Identité : Session ID au lieu du numéro de téléphone

 
coté OSINT , WhatsApp, Signal ou Telegram reposent sur un numéro de téléphone comme identifiant unique. Cela relie immédiatement votre compte à votre identité réelle.

!["telegram Meme"](https://blog.lbrs.io/images/telegram_meme.png)

Session supprime cette dépendance:

Dès la première ouverture, votre appareil génère une paire de clés cryptographiques :

- Une **clé publique** (visible, identifiant unique)
- Une **clé privée** (secrète, permet de signer et déchiffrer)

Votre Session ID est dérivé de la clé publique. Exemple :  

```shell 
054344d3ecc368abd192edb15a13da76a9afe05e6bf33aea2ea150cf581b63cc1d 
````

C’est votre **pseudo technique**, sans lien avec numéro, mail ou carte SIM

Cela veut dire aucune donnée personnelle et aussi aucune corrélation possible



## Chiffrement : le « Session Protocol » basé sur libsodium

!["On Dit chiffrer bordel!"](https://blog.lbrs.io/images/chiffrer.jpg)

Session utilise son propre protocole, le **Session Protocol**, construit sur la bibliothèque open-source **libsodium** (aussi utilisée par Signal, Tor, WireGuard…)

Chaque message est :  
- Chiffré en End to End (E2EE)
- Signé numériquement (authenticité)
- Compressé et encapsulé avant envoi
- Il y a un échange de clés par rotation régulière
- Chaque conversation a ses propres clés dérivées
- Aucun serveur ne voit vos clés privées ni vos messages

les nœuds de transport ne peuvent rien lire



## Côté Routage : des relais style Tor

 
Les messages passent par trois relais aléatoires (service nodes) selon le principe du **routage en oignon** (comme Tor)

- Le premier nœud voit votre IP mais pas la destination
- Le dernier voit la destination mais pas l’expéditeur
- Chaque couche de chiffrement est retirée étape par étape

Aucun acteur ne peut determiner qui parle a qui

## Stockage différé : les “swarms”

Si le destinataire est hors-ligne, le message est stocké non pas sur un serveur central, mais dans un **swarm** (5 à 7 nœuds)

- Chaque swarm gère une plage de Session IDs
- Les messages chiffrés sont répliqués temporairement
- Seule la clé privée du destinataire permet d’ouvrir le message
- Suppression automatique après ~14 jours
- Si l’utilisateur ne se reconnecte pas, le message est perdu

les avantages sont qu'il ná pas pas de stockage central ou de stockage permanent a la difference d'autres acteurs de messageries instantanées.


## Les Groupes

Il existe sur session 2 types de groupes:

### les groupes fermés - privés
- Jusqu’à 100 membres
- E2EE complet
- Même gestion de clés que pour les conversations privées
- Routage via service nodes et swarms

Quelques dificultés de gestions au niveau des clients Ubuntu // je n'arrive pas a rejoindre un groupe

### les Open Groups / Communities  
- “Salons publics” du meme type que Telegram ou Discord
- Hébergés sur des serveurs appelés **SOGS**
- Messages chiffrés en transit (TLS), mais pas au repos
- Hébergement ouvert à tous

## Zero Trust pour les medias 

Quand vous envoyez une image, vidéo ou document :  

1. Il y a un chiffrement côté client
2. Dépôt du media sur un serveur open-source
3. Lien chiffré envoyé via la messagerie E2EE

Donc le serveur ne voit jamais le contenu, seulement des blobs chiffrés, Il n’a pas la clé pour les ouvrir, ni les noeuds du réseau, ni le serveur d'hébergement.

Pour Whatapp par exemple meta fait du chiffrement de bout en bout et les fichiers sont stockés sur les serveur Whatsapp sous forme chiffrée MAIS Meta gere une partie du systeme.
Meta ne lit pas le contenu, mais détient les métadonnées (qui parle à qui, quand, type de fichier, taille, IP…

la messagerie Signal tente de réduire au minimum ces métadonnnées, mais ne peut pas les éliminer complètement car il s’appuie sur une infrastructure centralisée.

Depuis 2021, Signal a introduit un système appelé Sealed Sender, qui masque l’expéditeur au serveur.

le serveur sait toujours qu’un message a transité, à quelle heure, et entre quelles clés publiques


## Les notifications

Session propose deux modes qui vous permettrosn de choisir entre vitesse et confidentialité absolue 

### un mode en mode rapide  
- Utilise les systèmes push Google (FCM) ou Apple (APNs)
- Rapide mais expose un jeton de push
- Ces services savent qu’une notif existe, mais pas son contenu

### b. Mode lent  
- L’app interroge régulièrement le réseau (swarm polling)
- Plus lent, plus gourmand en batterie, mais aucun contact avec Google/Apple


