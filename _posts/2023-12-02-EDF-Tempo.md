---
layout: post
title: "Better Consumption... Discovering the EDF Tempo Contract"
excerpt: "Analysis of your EDF consumption data with a projection on the new French EDF Tempo contract..."
excerpt_separator: "<!--more-->"
categories:
  - DIY
tags:
  - Python
  - Electronics
last_modified_at: 2023-12-03T11:23:22-02:00
---


The EDF Tempo contract is an electricity plan with varying rates based on the day, categorized into three colors (blue, white, red) indicating different tariffs, with red days being the most expensive. This plan aims to encourage consumption outside peak periods.
The offer may seem strange and perhaps worrying at first glance (the tariff on red days is very high at nearly 73 cents per kWh!, whereas in Tarif Bleu it's 22 cents). But it's worth examining. Obviously, we can calculate the advantages simply by taking the worst days of consumption over the year and applying a Red then White tariff to them... But the goal here is not only to better evaluate the savings but also to be able to track the periods or days when red days are often present and also to know if our consumption habits have an impact.

# Get and clean the datas

The EDF website offers you the option to download all your consumption data in CSV format:
the problem is that these formats will be very difficult to use, so we will first clean up this data:

![EDFDatas](https://blog.lbrs.io/images/DownloadEDFdatas.png)

here a script for the CleanUp:


```python
import pandas as pd

def update_file(input_file_path, output_file_path):
    with open(input_file_path, 'r', encoding='ISO-8859-1') as file:
        lines = file.readlines()

    current_date = None
    updated_lines = []

    for line in lines:
        
        line = line.strip()
        if line.endswith(';;'):
            
            current_date = line.split(';;')[0]
        else:
            
            if current_date:
                updated_line = f"{current_date};{line}"
                if not updated_line.endswith(';'):
                    updated_lines.append(updated_line)

    
    with open(output_file_path, 'w', encoding='ISO-8859-1') as file:
        for line in updated_lines:
            file.write(line + '\n')


input_file_path = 'datas/mes-puissances-atteintes-30min-1640-64.csv'
output_file_path = 'datas/mes-puissances-atteintes-30min-cleaned.csv'
update_file(input_file_path, output_file_path)

```

# Prices

We have our consumption data with all the history and the details of the hours with the associated consumption. It is now necessary to apply the tariffs.

![TarifsTempo.png](https://blog.lbrs.io/images/TarifsTempo.png)

I will get this:

```python
# DonnÃ©es des tarifs Ã©lectriques EDF

# Option Base
prixbase = [{'Puissance': 3, 'Abonnement': 9.47, 'PrixKW': 22.76}, {'Puissance': 6, 'Abonnement': 12.44, 'PrixKW': 22.76}, {'Puissance': 9, 'Abonnement': 15.63, 'PrixKW': 22.76}, {'Puissance': 12, 'Abonnement': 18.89, 'PrixKW': 22.76}, {'Puissance': 15, 'Abonnement': 21.92, 'PrixKW': 22.76}, {'Puissance': 18, 'Abonnement': 24.92, 'PrixKW': 22.76}, {'Puissance': 24, 'Abonnement': 31.6, 'PrixKW': 22.76}, {'Puissance': 30, 'Abonnement': 37.29, 'PrixKW': 22.76}, {'Puissance': 36, 'Abonnement': 44.66, 'PrixKW': 22.76}]

# Option Tempo
prixtempo = [{'Puissance': 6, 'Abonnement': 12.8, 'BLUE_HC': 10.56, 'BLUE_HP': 13.69, 'WHITE_HC': 12.46, 'BLUE_HP': 16.54, 'RED_HC': 13.28, 'RED_HP': 73.24}, {'Puissance': 9, 'Abonnement': 16.0, 'BLUE_HC': 10.56, 'BLUE_HP': 13.69, 'WHITE_HC': 12.46, 'WHITE_HP': 16.54, 'RED_HC': 13.28, 'RED_HP': 73.24}, {'Puissance': 12, 'Abonnement': 19.29, 'BLUE_HC': 10.56, 'BLUE_HP': 13.69, 'WHITE_HC': 12.46, 'WHITE_HP': 16.54, 'RED_HC': 13.28, 'RED_HP': 73.24}, {'Puissance': 15, 'Abonnement': 22.3, 'BLUE_HC': 10.56, 'BLUE_HP': 13.69, 'WHITE_HC': 12.46, 'WHITE_HP': 16.54, 'RED_HC': 13.28, 'RED_HP': 73.24}, {'Puissance': 18, 'Abonnement': 25.29, 'BLUE_HC': 10.56, 'BLUE_HP': 13.69, 'WHITE_HC': 12.46, 'WHITE_HP': 16.54, 'RED_HC': 13.28, 'RED_HP': 73.24}, {'Puissance': 30, 'Abonnement': 38.13, 'BLUE_HC': 10.56, 'BLUE_HP': 13.69, 'WHITE_HC': 12.46, 'WHITE_HP': 16.54, 'RED_HC': 13.28, 'RED_HP': 73.24}, {'Puissance': 36, 'Abonnement': 44.28, 'BLUE_HC': 10.56, 'BLUE_HP': 13.69, 'WHITE_HC': 12.46, 'WHITE_HP': 16.54, 'RED_HC': 13.28, 'RED_HP': 73.24}]
```

# Tempo Vision Project - Get API

RTE France offers access to its data via a very practical API. It is possible through this API to retrieve all the historical data of red, blue, or white days by date. Perfect, that's exactly what I need. So, I begin the work.

![TempoVision](https://blog.lbrs.io/images/TempoVision.png)

The project consists of API constants (the shared secret and the authorization key), functions that will request the access token, and retrieve Tempo data for a given date range. On these same dates, we will extract the consumption, calculate the cost in Tarif Bleu, and calculate the cost in Tarif Tempo according to the tariff tables, but using the historical data of Tempo. This is an important parameter because in January there are more consumption peaks and this can have an impact on your annual rate.

Finally, I use the Matplotlib libraries and represent all this data:

![AnnualConso](https://blog.lbrs.io/images/graph.png)

# go further for the tempo tracking

## Get Date
```python
import requests
from datetime import datetime, timedelta

def get_access_token(base64_auth_str):
    """
    RÃ©cupÃ¨re un access token pour l'API.
    """
    token_url = "https://digital.iservices.rte-france.com/token/oauth"
    headers = {
        "Authorization": f"Basic {base64_auth_str}",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    data = {"grant_type": "client_credentials"}
    response = requests.post(token_url, data=data, headers=headers)

    if response.status_code == 200:
        return response.json().get("access_token")
    else:
        print("Erreur lors de l'obtention du token:", response.status_code)
        print(response.text)
        return None

def get_color_emoji(color):
    emojis = {
        'RED': 'ðŸ”´',
        'WHITE': 'âšª',
        'BLUE': 'ðŸ”µ'
    }
    return emojis.get(color, '')  # Retourne l'emoji correspondant ou une chaÃ®ne vide si la couleur n'est pas trouvÃ©e

def get_tempo_like_calendar(access_token, start_date, end_date):
    """
    RÃ©cupÃ¨re les informations de l'API pour les dates spÃ©cifiÃ©es.
    """
    api_url = (f"https://digital.iservices.rte-france.com/open_api/tempo_like_supply_contract/v1/tempo_like_calendars"
               f"?start_date={start_date}&end_date={end_date}&fallback_status=true")
    headers = {'Authorization': f'Bearer {access_token}', 'Accept': 'application/json'}
    response = requests.get(api_url, headers=headers)

    if response.status_code == 200:
        return response.json()
    else:
        print("Erreur lors de la rÃ©cupÃ©ration des donnÃ©es:", response.status_code)
        print(response.text)
        return None

def format_response(api_response):
    try:
        values = api_response['tempo_like_calendars']['values']
        formatted_responses = []

        for value in values:
            color = value['value']
            color_emoji = get_color_emoji(color)

            start_date = datetime.fromisoformat(value['start_date'])
            formatted_date = start_date.strftime("%Y-%m-%d")
            formatted_responses.append(f"{formatted_date}: {color} {color_emoji}")

        return '\n'.join(formatted_responses)
    except KeyError as e:
        return "Erreur lors du formatage de la rÃ©ponse: " + str(e)

# Main execution
if __name__ == "__main__":
    base64_auth_str = "----YOUR API TOKEN -- See RTE TEmpo API like calendar"
    access_token = get_access_token(base64_auth_str)

    if access_token:
        start_date = (datetime.now() - timedelta(days=3)).strftime("%Y-%m-%dT00:00:00+01:00")
        end_date = (datetime.now() + timedelta(days=2)).strftime("%Y-%m-%dT00:00:00+01:00")

        response = get_tempo_like_calendar(access_token, start_date, end_date)

        if response:
            formatted_response = format_response(response)
            print(formatted_response)
        else:
            print("Aucune donnÃ©e retournÃ©e.")


```

## Raspberry Pi LEDs Notification

When we have a Tempo offer in place, the goal is to be regularly informed of day changes, especially if it switches to white or red because we will have to adapt our electricity consumption. 
Apart from being able to automate equipment (via home assistant, or Synology programming), it is interesting to be able to be notified.
i did connect 6 Leds to raspberry pi to be able to get easily the info and build a program to switch the LEDs on 

![Gpio](https://blog.lbrs.io/images/gpio.png)
![montage1](https://blog.lbrs.io/images/MontageJ.png)
![montage2](https://blog.lbrs.io/images/MontageN.png)

## Telegram Bot Notification

```python
import requests
import subprocess

def send_telegram_message(text, bot_token, chat_id):
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": text
    }
    requests.post(url, data=payload)

def get_script_output():
    process = subprocess.Popen(["python3", "/opt/TempoBot/getdate.py"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate()
    if error:
        return f"Erreur lors de l'exÃ©cution du script : {error.decode()}"
    return output.decode()

bot_token = "----YOUR TOKEN HERE-----"
chat_id = "YOUR CHAT ID HERE"

result = get_script_output()
send_telegram_message(result, bot_token, chat_id)

```
![Bot](https://blog.lbrs.io/images/TG-bot.jpg)


### Video Presentations
![\[2023-12-03\] \[cdrc lbrs\] -> \[vimeo.com/890851476?share=copy\](https://vimeo.com/890851476?share=copy)  



